<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AblativeCoat" xml:space="preserve">
    <value>Ablative Coat absorbs the next 3 Damage your robot recieves. Put those Damage tokens onto this card instead of onto your Program Sheet. Discard this card when you put the third one on.</value>
  </data>
  <data name="AbortSwitch" xml:space="preserve">
    <value>Once each turn, you may replace one of the Program cards you reveal with the top card from the deck. If you do, you must replace the Program cards for all your remaining registers the same way that turn.</value>
  </data>
  <data name="Brakes" xml:space="preserve">
    <value>Whenever you execute a move 1, you may move your robot 0 spaces instead of 1. Priority is that of the Move 1.</value>
  </data>
  <data name="CircutBreaker" xml:space="preserve">
    <value>If you have 3 or more Damage tokens on your Program Sheet at the end of your turn, your robot will begin the next turn powered down. </value>
  </data>
  <data name="ConditionalProgramming" xml:space="preserve">
    <value>After you program your registers each turn, you may put one of the Program cards left in your hand face down onto this Option instead of discarding it. Later that turn, you can substitute that card for one you had programmed into any register, discarding the original card. Announce the change before anyone reveals Program cards for that register. If you put a card on this Option and don't use it, discard it at the end of the turn.</value>
  </data>
  <data name="CrabLegs" xml:space="preserve">
    <value>When programming your registers, you may put a Move 1 card in the same register as a Rotate Left or Rotate Right card. If you do, during that register your robot will move 1 space to the left or right, respectively, without rotating. Priority is that of the Move 1.</value>
  </data>
  <data name="DoubleBarreledLaser" xml:space="preserve">
    <value>Whenever your robot files it's main laser, fires two shots instead of one. You may use this Option with Fire Control and/or High Powered Laser.</value>
  </data>
  <data name="DualProcessor" xml:space="preserve">
    <value>When programming your registers, you may put both a Move card (Move 1, Move 2, Move 3, or Back Up) and a Rotate card (Rotate Left, Rotate Right, or U-Turn) in the same register. If you do, during that phase your robot will move 1 space less than the Move card says to move and then execute the Rotate card. If the Rotate card is a U-Turn, move 2 spaces less than the Move card says if possible.</value>
  </data>
  <data name="ExtraMemory" xml:space="preserve">
    <value>You receive one extra Program card each turn. (You still discard all unused Program cards when you're done progamming your registers.)</value>
  </data>
  <data name="FireControl" xml:space="preserve">
    <value>Whenever your robot hits another robot with its main laser, instead of doing damage you may choose one of the target robot's registers and lock it or choose one of that player's Options and destroy it. (The player can't discard an Option to avoid this effect.)</value>
  </data>
  <data name="Flywheel" xml:space="preserve">
    <value>After all players are done programming their registers each turn, you may put one card of your remaining Programming cards face down onto this card. You can add that Programming card to those dealt to you on any subsequent turn. You can have only one card on Flywheel at a time.</value>
  </data>
  <data name="FourthGear" xml:space="preserve">
    <value>Whenever you execute a Move 3, you may move your robot 4 spaces instead of 3. Priority is that of the Move 3.</value>
  </data>
  <data name="GyroscopicStablizer" xml:space="preserve">
    <value>Before players reveal the cards in their first registers each turn, state whether this Option is active. When it is, your robot isn't rotated by gears or rotating conveyor belts for that entire turn.</value>
  </data>
  <data name="HighPoweredLaser" xml:space="preserve">
    <value>Your robot's main laser can shoot through one wall or robot to get to a target robot. If you shoot through a robot, that robot also receives full damage. You may combine this Option with Fire Control and/or Double-Barreled Laser.</value>
  </data>
  <data name="MechanicalArm" xml:space="preserve">
    <value>Your robot can touch a flag or repair site from 1 space away (diagonally or othogonally), as long as there isn't a wall between it and the flag or repair site.</value>
  </data>
  <data name="MiniHowitzer" xml:space="preserve">
    <value>Whenever you could fire your main laser at a robot, you may fire the Mini Howitzer instead. This pushes the target robot 1 space away from your robot, and the target robot receives 1 Damage token. (Robots can't be pushed through walls.) You may use this Option five times. Put a Damage token on this card each time you use it and discard this card and the tokens when you put the fifth one on.</value>
  </data>
  <data name="PowerDownShield" xml:space="preserve">
    <value>As long as your robot is powered down, each register ohase you can prevent up to 1 Damage to it from each of the four directions.</value>
  </data>
  <data name="PressorBeam" xml:space="preserve">
    <value>Whenever you could fire your main laser at a robot, you may instead fire the Pressor Beam. This moves the target robot 1 space away from your robot.</value>
  </data>
  <data name="RadioControl" xml:space="preserve">
    <value>Whenever you could fire your main laser at a robot, you may instead fire the Radio Control beam. This causes the target robot to execute your robot's program for the rest of the turn. In the cases of card priority, the target robot moves immediately after your robot.</value>
  </data>
  <data name="RammingGear" xml:space="preserve">
    <value>Whenever your robot pushes or bumps into another robot, that robot receives 1 Damage token.</value>
  </data>
  <data name="RearFiringLaser" xml:space="preserve">
    <value>Your robot has a rear-firing laser inaddition to its main laser. This laser follows all the same rules as the main laser.</value>
  </data>
  <data name="Recompile" xml:space="preserve">
    <value>Once each turn, you may discrd the hand of Programming cards dealt to you and draw a new hand from the deck. Your robot then receives 1 Damage token.</value>
  </data>
  <data name="ReverseGear" xml:space="preserve">
    <value>Whenever you execute a Back Up, you maymove your robot back 2 spaces instead of 1. Priority is that of the Back Up.</value>
  </data>
  <data name="Scrambler" xml:space="preserve">
    <value>Whenever you could fire your main laser at a robot, you may instead fire the Scrambler. This replaces the target robot's next programmed card with the top Program card from the deck. You can't use this Option on the fifth register phase.</value>
  </data>
  <data name="SuperiorArchive" xml:space="preserve">
    <value>When reentering play after being destroyed, your robot doesn't receive the normal 2 Damage tokens.</value>
  </data>
  <data name="TractorBeam" xml:space="preserve">
    <value>Whenever you could fire your main laser at a robot that isn't in an adjacent space, you may instead fire the Tractor Beam. This pulls the target robot 1 space toward your robot.</value>
  </data>
</root>